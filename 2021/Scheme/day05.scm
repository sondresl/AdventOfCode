(load "utils.scm")
(load "point-map.scm")

(define input (read-line-string "../data/day05.in"))

;; Custom parsing
(define (parse-points lines)
  (define (parse-tuple parts)
    (let ((res (map (compose string->number list->string) (split-on #\, parts))))
      (cons (car res) (cadr res))))
  (define (inner line)
    (let* ((parts (split-on #\space (string->list line)))
           (first (parse-tuple (car parts)))
           (snd (parse-tuple (caddr parts))))
      (cons first snd)))
  (map inner lines))

(define (line-segment points)
  (define (make-delta x y)
    (cond ((= x y) 0)
          ((> y x) 1)
          (else -1)))
  (define (make-segment x0 y0 x1 y1 dx dy)
    (define (inner x0 y0)
      (if (and (= x0 x1) (= y0 y1))
        (list (cons x1 y1))
        (cons (cons x0 y0)
              (inner (+ x0 dx) (+ y0 dy)))))
    (inner x0 y0))
  (let* ((x0 (caar points))
         (y0 (cdar points))
         (x1 (cadr points))
         (y1 (cddr points)))
    (make-segment x0 y0 x1 y1 (make-delta x0 x1) (make-delta y0 y1))))

(define (run f points)
  (let* ((all-points (apply append (map line-segment (filter f points))))
         (max-x (apply max (map car all-points)))
         (max-y (apply max (map cdr all-points))))
      (count (partial < 1) (vector->list ((point-map max-x max-y 0) all-points)))))

(define (main)
  (define (one-equal points)
    (let ((first (car points))
          (snd (cdr points)))
      (or (= (car first) (car snd))
          (= (cdr first) (cdr snd)))))
  (let* ((points (parse-points input))
         (part1 (run one-equal points))
         (part2 (run (const #t) points)))
    (cons part1 part2)))

(main)

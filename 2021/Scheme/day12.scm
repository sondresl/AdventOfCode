(load "utils.scm")

(define (parse filename)
  (->> (read-line-string filename)
       (map string->list)
       (map (comp (lambda (x) (cons (car x) (cadr x))) 
                  (fmap list->string) 
                  (partial split-on #\-)))
       (map (lambda (x) (list (cons (car x) (cdr x))
                              (cons (cdr x) (car x)))))
       (apply append)))

(define (make-graph edges)
  (define (go gr new)
    (cond ((null? gr) (list (list (car new) (cdr new))))
          ((string=? (caar gr) (car new))
           (cons (cons (car new) (filter (lambda (x) (not (string=? "start" x))) 
                                         (cons (cdr new) (cdar gr))))
                 (cdr gr)))
          (else (cons (car gr)
                      (go (cdr gr) new)))))
  (foldl go '() edges))

(define (is-lower str)
  (let ((ch (char->integer (car (string->list str)))))
    (and (<= (char->integer #\a) ch (char->integer #\z)))))

(define (dfs start goTwice? edges)
  (define (inner current path goTwice? count)
    (if (string=? "end" current)
      (inc count)
      (let* ((nexts (cdr (assoc current edges))))
        (let loop ((next nexts)
                   (count count))
          (cond ((null? next) count)
                ((not (is-lower (car next)))
                 (loop (cdr next) (inner (car next) (cons (car next) path) goTwice? count)))
                ((member (car next) path)
                 (if goTwice?
                   (loop (cdr next) (inner (car next) (cons (car next) path) #f count))
                   (loop (cdr next) count)))
                (else (loop (cdr next) (inner (car next) (cons (car next) path) goTwice? count))))))))
  (inner start '() goTwice? 0))

(define (main)
  (let ((graph (make-graph (parse "../data/day12.in"))))
    (cons (dfs "start" #f graph)
          (dfs "start" #t graph))))

(main)
